// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`unit should parse a unit dir containing a part dir with a README.md 1`] = `
Object {
  "00-opening": Object {
    "body": "<h2 id=\\"&#xBF;por-qu&#xE9;-aprender-esto\\">&#xBF;Por qu&#xE9; aprender esto?</h2>
<p>Como indica el nombre del curso, vamos a hablar de <em>Paradigmas de programaci&#xF3;n</em>,
que son formas diferentes de pensar en c&#xF3;mo se organiza un programa.</p>
<p>Como desarrollador <strong>Full Stack JS</strong> es esencial entender los distintos
paradigmas de programaci&#xF3;n y c&#xF3;mo se traducen al mundo real en proyectos de
JavaScript.</p>
<p>Hist&#xF3;ricamente, el paradigma orientado a objetos (OOP) ha sido el predominante,
pero recientemente, y en particular en la comunidad de JavaScript, hay un
resurgir del paradigma funcional y sus bondades. <strong>JavaScript es un lenguaje de
coraz&#xF3;n funcional</strong>, as&#xED; que conocer el paradigma, y c&#xF3;mo se compara a la
programaci&#xF3;n orientada a objetos, no s&#xF3;lo te har&#xE1; una mejor coder, si no que
podr&#xE1;s entender c&#xF3;mo se pueden enfrentar los mismos problemas con enfoques
distintos, e identificar y adaptarse a bases de c&#xF3;digo existentes.</p>
<p>En este curso nos concentraremos en los paradigmas m&#xE1;s relevantes para
JavaScript y c&#xF3;mo se materializan en este contexto.</p>
<h2 id=\\"gu&#xED;a-de-preguntas-y-conceptos-clave\\">Gu&#xED;a de preguntas y conceptos clave</h2>
<p>Cuando empezamos a estudiar un tema nuevo, es &#xFA;til tener una idea de los
conceptos m&#xE1;s importantes de lo que vamos a aprender y de los temas centrales
que debemos prestar particular atenci&#xF3;n.</p>
<p>A continuaci&#xF3;n te presentamos una serie de preguntas que debes ser capaz de
responder al terminar esta unidad. Utiliza estas preguntas como gu&#xED;a para
orientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida
que avanzas para validar que est&#xE1;s avanzando en la direcci&#xF3;n correcta. Que te
sirva como un &quot;checklist&quot; que vas marcando a medida que vas progresando.</p>
<ul>
<li>Qu&#xE9; son los <strong>paradigmas de programaci&#xF3;n</strong>?</li>
<li>Qu&#xE9; es el estilo <strong>imperativo</strong></li>
<li>Qu&#xE9; es el estilo <strong>declarativo</strong></li>
<li>Qu&#xE9; paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n por procedimientos</strong>?</li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n orientada a objetos</strong>?</li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n funcional</strong>?</li>
<li>C&#xF3;mo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>C&#xF3;mo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>C&#xF3;mo programar en los diferentes estilos</li>
</ul>
",
    "duration": 5,
    "format": "self-paced",
    "title": "Apertura",
    "type": "read",
  },
  "01-overview": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/6frz31ykmi?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>Los <strong>Paradigmas de Programaci&#xF3;n</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en c&#xF3;mo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Consideremos la siguiente funci&#xF3;n:</p>
<pre><code class=\\"language-js\\">function sum(array) {
  var total = 0;
  for (var i = 0; i &lt; array.length; i++) {
    total += array[i];
  }
  return total;
}</code></pre>
<p>La funci&#xF3;n <code>sum(array)</code> recibe un array de n&#xFA;meros y retorna la suma de todos
los elementos del array. Para llevar a cabo la suma, usamos la variable <code>total</code>,
la cual vamos a ir actualizando (mutando) mientras vamos recorriendo el arreglo
con un bucle (<code>for</code> en este caso). Estas caracter&#xED;sticas son t&#xED;picas del estilo
imperativo.</p>
<p>Ahora, podemos implementar exactamente la misma funcionalidad usando un enfoque
completamente distinto.</p>
<pre><code class=\\"language-js\\">function sum(array) {
  if (!array.length) {
    return 0;
  }
  return array[0] + sum(array.slice(1));
};</code></pre>
<p>En esta segunda implementaci&#xF3;n, la funci&#xF3;n <code>sum(array)</code> sigue teniendo la misma
interfaz (recibe los mismos argumentos y retorna lo mismo), pero claramente
podemos ver que la l&#xF3;gica se expresa de una manera muy diferente. En la versi&#xF3;n
recursiva hemos reemplazado el bucle <code>for</code> por recursi&#xF3;n, y adem&#xE1;s podemos ver
que no hay asignaci&#xF3;n ni mutaci&#xF3;n de variables, el &quot;c&#xF3;mputo&quot; se hace por
aplicaci&#xF3;n de argumentos a funciones. Este tipo de caracter&#xED;sticas son propias
del paradigma funcional.</p>
<hr>
<p>PRO TIP:</p>
<p>Haciendo uso de ES2015 podemos refactorizar la versi&#xF3;n funcional de <code>sum</code> de
esta manera:</p>
<pre><code class=\\"language-js\\">const sum = array =&gt; !array.length ? 0 : array[0] + sum(array.slice(1));</code></pre>
<hr>
<p>Cuando hablamos de <strong>Paradigmas de Programaci&#xF3;n</strong> inevitablemente tenemos que
hablar de lenguajes de programaci&#xF3;n. Algunos lenguajes, como JavaScript, son
<em>multi-paradigma</em>, lo que quiere decir que nos permiten programar en diferentes
paradigmas, mientras que otros se enfocan espec&#xED;ficamente en uno.</p>
<p><strong>JavaScript</strong> es un leguage <em>h&#xED;brido</em>, por decirlo de alguna forma, y contiene
elementos propios de lenguajes funcionales (por ejemplo funciones como objetos
de primera clase, lambdas, ...) pero no estamos limitados al paradigma
funcional. <strong>JavaScript nos permite programar de forma <em>funcional</em>, <em>orientado a
objetos</em>, <em>orientado a eventos</em>, <em>por procedimientos</em>, ...</strong></p>
<p>Tambi&#xE9;n veremos que los &quot;paradigmas&quot; son &quot;estilos&quot; de programaci&#xF3;n que no son
necesariamente exclusivos. De hecho, algunos son complementarios o evoluciones
de paradigmas m&#xE1;s antiguos o con un nivel de abstracci&#xF3;n m&#xE1;s bajo. As&#xED;, la
programaci&#xF3;n procedural y orientada a objetos, por ejemplo, ambas son
imperativas, ya que comparten una ra&#xED;z com&#xFA;n.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/\\" target=\\"_blank\\">Six programming paradigms that will change how you think about coding</a>,
Yevgeniy Brikman, Apr 09 2014</li>
</ul>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe id=\\"ytplayer\\" type=\\"text/html\\" width=\\"640\\" height=\\"360\\" frameborder=\\"0\\" src=\\"https://www.youtube.com/embed/sqV3pL5x8PI?autoplay=0\\"></iframe></div>,
<code>10:43</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
30 Aug 2013</li>
<li><div class=\\"iframe-container\\"><iframe id=\\"ytplayer\\" type=\\"text/html\\" width=\\"640\\" height=\\"360\\" frameborder=\\"0\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
<li><a href=\\"https://www.video2brain.com/mx/tutorial/que-es-un-paradigma-de-programacion\\" target=\\"_blank\\">Qu&#xE9; es un paradigma de programaci&#xF3;n</a>,
<code>5:15</code>, Jos&#xE9; Dimas Luj&#xE1;n Castillo, <a href=\\"https://www.video2brain.com/\\" target=\\"_blank\\">video2brain</a>,
8 Mar 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Programming_paradigm\\" target=\\"_blank\\">Definici&#xF3;n de Programming_paradigm en Wikipedia</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms\\" target=\\"_blank\\">Comparativa de paradigmas de programaci&#xF3;n en Wikipedia</a></li>
</ul>
",
    "duration": 5,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/6frz31ykmi?wvideo=6frz31ykmi",
        "id": "6frz31ykmi",
        "provider": "wistia",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=sqV3pL5x8PI",
        "id": "sqV3pL5x8PI",
        "provider": "youtube",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
        "id": "4A2mWqLUpzw",
        "provider": "youtube",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "¿Qué son los paradigmas de programación?",
    "type": "read",
  },
  "02-history": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/an9covln5w?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>Para tener una idea general de los paradigmas y sus peculiaridades, es &#xFA;til
repasar brevemente su historia.</p>
<p>El primer paradigma en aparecer, primera mitad de los a&#xF1;os 50, es el
<strong>imperativo</strong>, que se caracteriza por un nivel bajo de abstracci&#xF3;n. Por lo
tanto el c&#xF3;digo est&#xE1; enfocado en las instrucciones que la computadora debe
seguir, y no necesariamente en la sem&#xE1;ntica o l&#xF3;gica de la funcionalidad que
estamos implementando (el c&#xF3;mo nosotros pensamos en lo que hace el programa).</p>
<p>Veamos un ejemplo de <code>Assembly</code>, el primer lenguaje &quot;moderno&quot;, que apareci&#xF3; en
el a&#xF1;o 1949, y que sigue vivo a d&#xED;a de hoy, eso s&#xED;, para cosas muy espec&#xED;ficas,
que nos son necesariamente lo que vemos los desarrolladores web, pero que sirve
para este ejemplo ;-)</p>
<pre><code class=\\"language-assembly_x86\\">section .text             ;section declaration

                          ;we must export the entry point to the ELF linker or
  global  _start          ;loader. They conventionally recognize _start as their
                          ;entry point. Use ld -e foo to override the default.

_start:

                          ;write our string to stdout

  mov     edx,len         ;third argument: message length
  mov     ecx,msg         ;second argument: pointer to message to write
  mov     ebx,1           ;first argument: file handle (stdout)
  mov     eax,4           ;system call number (sys_write)
  int     0x80            ;call kernel

                          ;and exit

  mov     ebx,0           ;first syscall argument: exit code
  mov     eax,1           ;system call number (sys_exit)
  int     0x80            ;call kernel

section .data             ;section declaration

msg db    &quot;Hello, world!&quot;,0xa    ;our dear string
len equ   $ - msg                ;length of our dear string</code></pre>
<p><a href=\\"http://www.tldp.org/HOWTO/Assembly-HOWTO/hello.html\\" target=\\"_blank\\">Fuente: Assembly-HOWTO</a></p>
<p>El snippet de arriba es un &quot;hello world&quot; escrito en <code>Assembly</code> (una versi&#xF3;n
moderna, pero muy parecido a lo que hubieras visto en los a&#xF1;os 50). Lo &#xFA;nico que
hace este programa es imprimir el string <code>Hello, world!</code>. El equivalente a todo
el c&#xF3;digo de arriba en JavaScript ser&#xED;a:</p>
<pre><code class=\\"language-js\\">console.log(&apos;Hello, world!&apos;);</code></pre>
<p>En nuestro caso, JavaScript tiene un nivel de abstracci&#xF3;n mucho m&#xE1;s alto. Con lo
cual, no tenemos que preocuparnos de muchos detalles que JavaScript ya abstrae
para nosotros, como manejo de memoria, instrucciones del procesador, etc. Esto
nos permite expresar de forma m&#xE1;s &quot;humana&quot; la intenci&#xF3;n de nuestro programa, y
con mucho menos c&#xF3;digo.</p>
<p>Regresamos a los a&#xF1;os 50. Seg&#xFA;n la programaci&#xF3;n va evolucionando, y los
programas creciendo, vemos c&#xF3;mo van a ir surgiendo diferentes formas de
&quot;abstraer&quot;, &quot;organizar&quot; y &quot;reusar&quot; el c&#xF3;digo. A finales de los a&#xF1;os 50 vemos
como aparecen <strong>Fortran II</strong> y <strong>Lisp</strong>, introduciendo la programaci&#xF3;n
<strong>procedural</strong> y <strong>funcional</strong>. Con ambos enfoques pasamos a nuevos nieveles de
abstracci&#xF3;n y mejora en el reuso de c&#xF3;digo.</p>
<p>En los a&#xF1;os 70 y 80 se da el boom de la programaci&#xF3;n orientada a objetos,
primero con <strong>Smalltalk</strong> y despu&#xE9;s <strong>C++</strong>.</p>
<p><strong>JavaScript</strong> nace en 1995, el mismo a&#xF1;o que <strong>Java</strong>, <strong>Ruby</strong> y <strong>PHP</strong>. La
d&#xE9;cada de los 90 se caracteriza por los lenguajes multi-paradigma. En ese
contexto JavaScript destaca por su dinamismo y su naturaleza funcional. De hecho
a nivel conceptual, JavaScript est&#xE1; fuertemente inspirado por <strong>Scheme</strong>, que es
un lenguaje funcional, y los prototipos de <strong>Self</strong>, aunque por necesidades del
mercado, la sint&#xE1;xis se parece m&#xE1;s a la familia de lenguajes de <strong>C</strong> y
<strong>Java</strong>, que son imperativos. Por esta raz&#xF3;n, JavaScript se considera muchas
veces <a href=\\"http://javascript.crockford.com/javascript.html\\" target=\\"_blank\\">el lenguaje m&#xE1;s
incomprendido</a>, y quiz&#xE1;s
confuso.</p>
<p>Como referencia, abajo podemos ver una tabla con algunos de los lenguajes m&#xE1;s
significativos a nivel de cambios de paradigma, y el conexto en el que aparece
JavaScript.</p>
<table>
<thead>
<tr>
<th>A&#xF1;o</th>
<th>Lenguaje</th>
<th>Paradigma</th>
</tr>
</thead>
<tbody><tr>
<td>1949</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Assembly_language\\" target=\\"_blank\\">Assembly</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1957</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran\\" target=\\"_blank\\">Fortran</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran#FORTRAN_II\\" target=\\"_blank\\">Fortran II</a></td>
<td>imperativo, procedural</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://goo.gl/ZbUXeg\\" target=\\"_blank\\">Lisp</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1965</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Simula\\" target=\\"_blank\\">Simula</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Smalltalk\\" target=\\"_blank\\">Smalltalk</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Prolog\\" target=\\"_blank\\">Prolog</a></td>
<td>l&#xF3;gico</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://goo.gl/4bnEHY\\" target=\\"_blank\\">C</a></td>
<td>imperativo, procedural, estructurado</td>
</tr>
<tr>
<td>1975</td>
<td><a href=\\"https://goo.gl/x2WMht\\" target=\\"_blank\\">Scheme</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1983</td>
<td><a href=\\"https://en.wikipedia.org/wiki/C%2B%2B\\" target=\\"_blank\\">C++</a></td>
<td>imperativo, procedural, estructurado, orientado a objetos</td>
</tr>
<tr>
<td>1987</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Perl\\" target=\\"_blank\\">Perl</a></td>
<td>imperativo, procedural, funcional, orientado a objetos, orientado a eventos</td>
</tr>
<tr>
<td>1991</td>
<td><a href=\\"https://goo.gl/bJ9Wcg\\" target=\\"_blank\\">Python</a></td>
<td>imperativo, procedural, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/PhfLjJ\\" target=\\"_blank\\">Ruby</a></td>
<td>imperativo, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/aWjoSR\\" target=\\"_blank\\">Java</a></td>
<td>imperativo, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/PHP\\" target=\\"_blank\\">PHP</a></td>
<td>imperativo, procedural, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/JavaScript\\" target=\\"_blank\\">JavaScript</a></td>
<td>imperativo, funcional, orientado a objetos, orientado a eventos</td>
</tr>
</tbody></table>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/History_of_programming_languages\\" target=\\"_blank\\">History of programming languages</a></li>
</ul>
",
    "duration": 5,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/an9covln5w?wvideo=an9covln5w",
        "id": "an9covln5w",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Historia",
    "type": "read",
  },
  "03-declarative-vs-imperative": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/ty5mr7p77t?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>Hemos mencionado que los primeros lenguajes de programaci&#xF3;n eran imperativos, y
que se centraban en el &quot;c&#xF3;mo&quot; m&#xE1;s que en el &quot;qu&#xE9;&quot;. Como contrapartida, el estilo
declarativo se caracteriza por lo contrario, enfocarse m&#xE1;s en &quot;qu&#xE9;&quot; queremos
hacer, desde el punto de vista de un ser humano, en vez de c&#xF3;mo lo debe ejecutar
la computadora. Por ende, cuanto m&#xE1;s declarativo, m&#xE1;s alejado del hardware.</p>
<p>Algunos paradigmas son m&#xE1;s imperativos y otros m&#xE1;s declarativos. Por ejemplo,
la programaci&#xF3;n orientada a procedimientos, o la programaci&#xF3;n orientada objetos,
van a tener un caracter imperativo, mientras que la programaci&#xF3;n funcional tiene
un caracter mucho m&#xE1;s declarativo.</p>
<p>Im&#xE1;ginemos que tenemos la siguiente data en un array de objetos:</p>
<pre><code class=\\"language-js\\">var array = [
  {id: &apos;uno&apos;, name: &apos;el primero&apos;},
  {id: &apos;dos&apos;, name: &apos;el segundo&apos;},
  {name: &apos;no tengo id&apos;}
];</code></pre>
<p>A partir de esta data, ahora nos piden extraer los <code>id</code> de cada un de los
objetos y amacenarlos en un nuevo arreglo (<code>ids</code>). Si nos planteamos el
problema desde un enfoque imperativo, podr&#xED;amos implementar una soluci&#xF3;n as&#xED;:</p>
<pre><code class=\\"language-js\\">const ids = [];

for (var i = 0; i &lt; array.length; i++) {
  if (array[i].id) {
    ids.push(array[i].id);
  }
}

console.log(ids); // [&apos;uno&apos;, &apos;dos&apos;]</code></pre>
<p>En el c&#xF3;digo anterior, probablemente puedas identificar claramente el estilo
imperativo. Las variables como &quot;contadores&quot; y &quot;acumuladores&quot;, son t&#xED;picos del
estilo imperativo. En este estilo el principal mecanismo de c&#xF3;mputo se lleva a
cabo a trav&#xE9;s de la asignaci&#xF3;n de valores en variables. Veremos as&#xED; uso de
variables globales y mutaci&#xF3;n de los valores asignados a variables a trav&#xE9;s del
tiempo.</p>
<p>JavaScript nos ofrece utilidades para afrontar este tipo problemas desde el
enfoque funcional. As&#xED;, los arrays (gracias a <code>Array.prototype</code>) tienen una
serie de m&#xE9;todos para manipular su data a trav&#xE9;s de &quot;higher order functions&quot;,
que en este caso son funciones que aceptan otra funci&#xF3;n como argumento, como por
ejemplo <code>Array.prototype.filter</code> o <code>Array.prototype.map</code>. Veamos c&#xF3;mo podemos
usar estas herramientas para implementar la misma l&#xF3;gica:</p>
<pre><code class=\\"language-js\\">const ids = array
  .filter(item =&gt; typeof item.id === &apos;string&apos;)
  .map(item =&gt; item.id);

console.log(ids); // [&apos;uno&apos;, &apos;dos&apos;]</code></pre>
<p>En esta nueva versi&#xF3;n hacemos lo siguiente:</p>
<ol>
<li>Usamos <code>Array#filter</code> para crear un nuevo arreglo s&#xF3;lo con aquellos elementos
que tengan un <code>id</code> que sea un string (<code>typeof item.id === &apos;string&apos;</code>).</li>
<li>Usamos <code>Array#map</code> para transformar cada elemento del arreglo y crear un
nuevo arreglo con los resultados.</li>
</ol>
<p>De esta forma los detalles de la iteraci&#xF3;n quedan escondidos detr&#xE1;s de
<code>Array#filter</code> y <code>Array#map</code>, haciendo nuestro c&#xF3;digo m&#xE1;s declarativo.</p>
<p>Tambi&#xE9;n podemos ver c&#xF3;mo &quot;encadenamos&quot; (method chaining) las invocaciones de
<code>filter</code> y <code>map</code> ya que ambas retornan un array, que a su vez tiene todos los
m&#xE9;todos de <code>Array.prototype</code>.</p>
<p>El estilo declarativo depende de que el lenguaje (o librer&#xED;as) nos ofrezcan este
tipo de herramientas o abstracciones con las que poder expresar nuestra l&#xF3;gica
sin preocuparnos tanto sobre los detalles de implementaci&#xF3;n.</p>
<p>Para terminar esta secci&#xF3;n, cabe mencionar que HTML es un lenguaje declarativo!
Muchos se quejar&#xED;an diciendo que HTML no es un lenguaje de programaci&#xF3;n, sino un
lenguaje de marcado (<em>markup language</em>). Pero podemos considerear a HTML como un
lenguaje declarativo muy restringido, no de uso general, donde s&#xF3;lo podemos
crear un &#xE1;rbol de nodos a partir de una estructura de etiquetas (<em>tags</em>) con una
sint&#xE1;xis y sem&#xE1;ntica predefinida. Es declarativo en el sentido de que no le
estamos diciendo a la computadora c&#xF3;mo convertir nuestro c&#xF3;digo en
instrucciones, sino que describimos de formal declarativa lo que queremos que
ocurra (el compilador o int&#xE9;rprete se encarga del resto).</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe id=\\"ytplayer\\" type=\\"text/html\\" width=\\"640\\" height=\\"360\\" frameborder=\\"0\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Imperative_programming\\" target=\\"_blank\\">Imperative programming</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Declarative_programming\\" target=\\"_blank\\">Declarative programming</a></li>
</ul>
",
    "duration": 15,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/ty5mr7p77t?wvideo=ty5mr7p77t",
        "id": "ty5mr7p77t",
        "provider": "wistia",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
        "id": "4A2mWqLUpzw",
        "provider": "youtube",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Declarativo vs Imperativo",
    "type": "read",
  },
  "04-imperative-exercise": Object {
    "duration": 5,
    "exercises": Object {
      "01-print-primes": Object {
        "body": "<p>La programaci&#xF3;n imperativa tiene un nivel de abstracci&#xF3;n bajo, lo que quiere
decir que se enfoca en describir, desde el punto de vista de la computadora,
c&#xF3;mo hacer lo que queremos. Nuestro c&#xF3;digo expresa de forma expl&#xED;cita el control
de flujo, usando bucles, declara variables para llevar la cuenta, ...</p>
<p>En el mundo real, en un lenguaje como JavaScript, vamos a encontrar
caracter&#xED;sticas de este paradigma, pero siempre en el contexto de otro paradigma
con un nivel de abtracci&#xF3;n m&#xE1;s alto y un mecanismo de reuso de c&#xF3;digo (c&#xF3;mo la
programaci&#xF3;n orientada a objetos o la prgramaci&#xF3;n funcional).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El <em>boilerplate</em> (la plantilla sobre la que hacer el ejercicio) contiene un
programa sin terminar. Este programa debe <strong>imprimir en la consola todos los
n&#xFA;meros primos menores que <code>20</code></strong>.</p>
<p>El <em>boilerplate</em> impementa s&#xF3;lo parte de la l&#xF3;gica. Por el momento imprime todos
los n&#xFA;meros enteros del <code>2</code> al <code>19</code>. Ahora tienes que a&#xF1;adir la l&#xF3;gica para
comprobar si un n&#xFA;mero es primo o no, y as&#xED; s&#xF3;lo imprimir los primos.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Debes implementar un bucle <code>for</code> anidado dentro del <code>for</code> ya existente.</li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<ul>
<li>Si un n&#xFA;mero es divisible por cualquier entero mayor que <code>1</code> que no sea el
n&#xFA;mero mismo, sabemos que NO es primo.</li>
<li>Dentro del bucle <code>for</code> principal, para ver si un n&#xFA;mero es primo, vamos a
tratar de demostrar que NO es primo, y si no podemos probar que no es primo,
entonces podemos asumir que s&#xED; es primo.</li>
<li>El operador <code>%</code> nos da el residuo de una divisi&#xF3;n.</li>
<li>Una vez que hemos probado que un n&#xFA;mero no es primo ya no necesitamos
continuar dividi&#xE9;ndolo.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://goo.gl/zn7cTu\\" target=\\"_blank\\">Arithmetic Operators: Remainder - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for\\" target=\\"_blank\\">Statements: for - MDN</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  // Iteramos desde 2 (el primer número primo) hasta 19 (menor que 20)
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    // Ahora debemos iterar desde \`2\` hasta \`i / 2\` usando una variable \`j\` como
    // contador.
    //
    // Para cada \`j\` comprueba si la división \`i / j\` deja un residuo.
    //
    // NOTA: No necesitamos probar números más allá de \`i / 2\` porque el
    // resultado de la división \`i / j\` siempre sería una fracción entre 2 y 1,
    // siempre dejando residuo.

    // TU CÓDIGO AQUÍ

    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
          },
          "c29sdXRpb24=": Object {
            "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;
    for (var j = 2; j <= (i / 2); j++) {
      if (i % j === 0) {
        isPrime = false;
        break;
      }
    }
    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
          },
          "dGVzdA==": Object {
            "cHJpbnRQcmltZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const Submission = require('../solution/printPrimes');


describe('printPrimes()', () => {

  const stub = Sinon.stub(console, 'log');
  Submission();
  stub.restore();

  it('debería exportar una función', () => {
    Assert.equal(typeof Submission, 'function');
  });

  it('debería invocar console.log 8 veces', () => {
    Assert.equal(stub.callCount, 8);
  });

  [[2], [3], [5], [7], [11], [13], [17], [19]].forEach((args, idx) => {
    it(\`invocación \${idx + 1} a console.log debería recibir \\"\${args[0]}\\" como único argumento\`, () => {
      Assert.deepEqual(args, stub.getCall(idx).args);
    });
  });

});
",
          },
        },
        "title": "Imprime los número enteros menores que 20",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio imperativo",
    "type": "practice",
  },
  "05-procedural": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/el19ibmhpj?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>La programaci&#xF3;n por procedimientos (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Antes mencionamos que a finales de los a&#xF1;os 50
Fortran II introduce la programaci&#xF3;n por procedimientos, y de esa forma
empezamos a &quot;organizar&quot;, &quot;abstraer&quot; y &quot;reusar&quot; nuestro c&#xF3;digo.</p>
<p>Cuando programamos orientados a procedimientos, lo cual puede ser un enfoque
v&#xE1;lido para ciertos programas o scripts, nos concentramos en agrupar c&#xF3;digo
en procedimientos o funciones, e invocar estos procedimientos con diferentes
argumentos o par&#xE1;metros. En este sentido es parecido a la programaci&#xF3;n
funcional, pero con la diferencia de que nos mantenemos en la rama imperativa,
describiendo acciones como pasos secuenciales, que podr&#xED;an tener efectos
secundarios y donde el output no est&#xE1; necesariamente deterinado por los
argumentos de entrada. Mientras que la programaci&#xF3;n funcional es m&#xE1;s abstracta,
se basa en funciones puras sin efectos secundarios, evitar el estado compartido,
y otros principios espec&#xED;ficos de la programaci&#xF3;n funcional.</p>
<p>Refactoricemos el ejemplo anterior donde sac&#xE1;bamos la propiedad <code>id</code> de una
lista de objetos. Empecemos por envolver el c&#xF3;digo en una funci&#xF3;n:</p>
<pre><code class=\\"language-js\\">function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (inputArray[i].id) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // [&apos;uno&apos;, &apos;dos&apos;]</code></pre>
<p>Este cambio parece menor, pero a&#xF1;ade una capa de abstracci&#xF3;n que nos da un
mont&#xF3;n de flexibilidad. Ahora nuestro c&#xF3;digo est&#xE1; <em>encapsulado</em> dentro de su
propio <em>scope</em> y podemos reusar la l&#xF3;gica para otros arrays (podemos invocar la
funci&#xF3;n cuantas veces queramos).</p>
<p>Pero vayamos un paso m&#xE1;s all&#xE1;. Ahora que estamos ordenando nuestro c&#xF3;digo usando
funciones, aprovechemos a abstraer y mejorar la comprobaci&#xF3;n que hac&#xED;amos para
saber si un objeto tiene una propiedad <code>id</code>.</p>
<pre><code class=\\"language-js\\">function hasId(obj) {
  return obj &amp;&amp; typeof obj.id === &apos;string&apos;;
}

function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (hasId(inputArray[i])) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // [&apos;uno&apos;, &apos;dos&apos;]
console.log(hasId()); // false
console.log(hasId({name: &apos;foo&apos;})); // false
console.log(hasId({id: &apos;uno&apos;})); // true</code></pre>
<p>En esta nueva versi&#xF3;n hemos partido el c&#xF3;digo en dos funciones, y al hacerlo
hemos tenido que dar nombres a estas funciones. Estos nombres representan de
alguna forma esa capa de abstracci&#xF3;n. Ahora podemos hablar de <code>hasId()</code>
cuando queremos referirnos a ese pedacito de l&#xF3;gica. As&#xED;, poco a poco vamos
creando una sem&#xE1;ntica que nos permite alejarnos de los detalles de
implementaci&#xF3;n.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Procedural_programming\\" target=\\"_blank\\">Procedural programming</a></li>
</ul>
",
    "duration": 6,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/el19ibmhpj?wvideo=el19ibmhpj",
        "id": "el19ibmhpj",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Programación por procedimientos",
    "type": "read",
  },
  "06-modules": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/ph5zkst0fv?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>Una de las consecuencias de estos cambios es el concepto de &quot;modularidad&quot;. Esto
va a permitir que empecemos a escribir programas estructurados en m&#xF3;dulos
independientes, que son m&#xE1;s f&#xE1;ciles de entender, testear, mantener, ...</p>
<p>En JavaScript existen varios sistemas de m&#xF3;dulos, principalmente <strong>AMD</strong>,
<strong>Common JS</strong> y <strong>ES2015/ES6</strong>. Para este ejemplo vamos a concentrarnos en
<strong>Common JS</strong>, que es el que usa <strong>Node.js</strong>, y que tambi&#xE9;n podemos usar en el
navegador gracias a los <em>bundlers</em>. En nuestro ejemplo, ahora que nuestro c&#xF3;digo
vive dentro de una funci&#xF3;n, podr&#xED;amos <em>exportar</em> la funci&#xF3;n, lo que nos
permitir&#xED;a usar esta funci&#xF3;n desde otros scripts u otros programas. Esto es
esencial para casi cuaquier programa o script hoy en d&#xED;a, con consecuencias que
damos por sentado como poder organizar nuestro c&#xF3;digo en archivos y carpetas
diferentes o tener dependecias de m&#xF3;dulos externos.</p>
<p>Para exportar nuestra funci&#xF3;n <code>getIds</code> usando Common JS en Node.js, podemos
simplemente asignar nuestra funci&#xF3;n a <code>module.exports</code>.</p>
<pre><code class=\\"language-js\\">// al final del script
module.exports = getIds;</code></pre>
<p>El objeto <code>module</code> es una variable local a cada script en Common JS. Si
asignamos algo a <code>module.exports</code>, &#xE9;ste ser&#xE1; el valor que recibiremos cuando
requiramos nuestro &quot;m&#xF3;dulo&quot;. Por ejemplo, imaginemos que salvamos el script en
el archivo <code>src/getIds.js</code>, y ahora lo queremos usar desde otro script afuera de
<code>src/</code>:</p>
<pre><code class=\\"language-js\\">const getIds = require(&apos;./src/getIds&apos;);
// \`getIds\` tiene el valor que hemos exportado a trav&#xE9;s de \`module.exports\`
// en el script \`src/getIds.js\`</code></pre>
<p>Common JS tambi&#xE9;n nos ofrece la opci&#xF3;n de exportar los valores que queramos
como propiedades del objeto <code>exports</code> (que es un alias de <code>module.exports</code>). As&#xED;
en vez de exportar s&#xF3;lo un valor (la funci&#xF3;n <code>getids</code>), podemos exporar varios
valores.</p>
<pre><code class=\\"language-js\\">exports.getIds = getIds;
exports.hasId = hasId;</code></pre>
<p>Ahora cuando requerimos nuestro m&#xF3;dulo desde otro script lo que recibimos es
un objeto (el objeto <code>exports</code>), que tiene dos propiedades, <code>getIds</code> y <code>hasId</code>.</p>
<pre><code class=\\"language-js\\">const myModule = require(&apos;./src/myModule&apos;);
// myModule.getIds()
// myModule.hasId()</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://2ality.com/2014/09/es6-modules-final.html\\" target=\\"_blank\\">ECMAScript 6 modules: the final syntax</a>,
Axel Rauschmayer, 07 Sep 2014</li>
<li><a href=\\"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\\" target=\\"_blank\\">JavaScript Modules: A Beginner&#x2019;s Guide</a>,
Preethi Kasireddy (FreeCodeCamp), Jan 22 2016</li>
</ul>
",
    "duration": 6,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/ph5zkst0fv?wvideo=ph5zkst0fv",
        "id": "ph5zkst0fv",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Modularidad",
    "type": "read",
  },
  "07-procedural-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-get-primes": Object {
        "body": "<p>La programaci&#xF3;n <em>procedural</em> (por procedimientos) introduce el concepto de
procedimientos o funciones que nos permiten agrupar instrucciones, y as&#xED; reusar
bloques de c&#xF3;digo e invocarlos con diferentes valores.</p>
<p>Seg&#xFA;n va creciendo un programa, vamos a tener la necesidad de organizar nuestro
c&#xF3;digo en pedacitos comprensibles, adem&#xE1;s de abstraer repetici&#xF3;n. La
programaci&#xF3;n por procedimientos representa un primer paso de abstracci&#xF3;n, lo que
nos obliga a tener que dar nombres a estos procedimientos, encapsularlos, y
definir sus interfaces (input/output).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Refactoriza el c&#xF3;digo que vimos en el ejercicio anterior en dos funciones:</p>
<ul>
<li><code>getPrimes(start, end)</code></li>
<li><code>isPrime(num)</code></li>
</ul>
<p>Ya hemos envuelto el c&#xF3;digo en una funci&#xF3;n con el nombre <code>getPrimes</code>.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>La funci&#xF3;n <code>getPrimes()</code> recibe dos argumentos: <code>start</code> y <code>end</code>, que nos deben
permitir especificar el rango de n&#xFA;meros primos que nos interesa.</li>
<li>La funci&#xF3;n <code>getPrimes()</code> debe retornar un <code>array</code> con los n&#xFA;meros primos en
vez de imprimirlos en la consola. Para ello usa una variable donde ir gurdando
los n&#xFA;meros primos que vayamos encontrando y al final de la funci&#xF3;n devuelve
(retorna) ese array.</li>
<li>En el bucle de <code>getPrimes()</code>, tendr&#xE1;s que sustituir el valor inicial de <code>i</code>
por <code>start</code> y la condici&#xF3;n por <code>i &lt; end</code>.</li>
<li>Dentro del bucle de <code>getPrimes()</code> ya no necesitamos la variable <code>isPrime</code>,
ahora debes invocar a la funci&#xF3;n <code>isPrime()</code> para determinar si el n&#xFA;mero en
cuesti&#xF3;n es primo.</li>
<li>El bucle que en el ejercicio anterior usamos para comprobar si un n&#xFA;mero es
primo, ahora debe quedar dentro de <code>isPrime()</code>, la cual s&#xF3;lo ha de recibir un
argumento (el n&#xFA;mero a comprobar) y retornar un booleano (<code>true</code> o <code>false</code>).</li>
<li>Aseg&#xFA;rate de que tu script exporta las funciones <code>getPrimes()</code> e <code>isPrime()</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions\\" target=\\"_blank\\">Functions - MDN</a></li>
<li><a href=\\"https://nodejs.org/api/modules.html#modules_the_module_object\\" target=\\"_blank\\">The module object - Node.js Docs</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  //...
}

function getPrimes(start, end) {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    //...

    if (isPrime) {
      console.log(i);
    }
  }
}
",
          },
          "c29sdXRpb24=": Object {
            "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  for (var i = 2; i <= (num / 2); i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}

function getPrimes(start, end) {
  var primes = [];
  for (var i = start; i < end; i++) {
    if (isPrime(i)) {
      primes.push(i);
    }
  }
  return primes;
}

exports.getPrimes = getPrimes;
exports.isPrime = isPrime;
",
          },
          "dGVzdA==": Object {
            "Z2V0UHJpbWVzLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/getPrimes');


describe('getPrimes(start, end)', () => {

  it('debería exportar función \`getPrimes\`', () => {
    Assert.equal(typeof Submission.getPrimes, 'function');
  });

  it('debería retornar los número primos menores de 20', () => {
    Assert.deepEqual(Submission.getPrimes(2, 20), [2, 3, 5, 7, 11, 13, 17, 19]);
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});


describe('isPrime(num)', () => {

  it('debería exportar función \`isPrime\`', () => {
    Assert.equal(typeof Submission.isPrime, 'function');
  });

  it('debería retornar true para 2, 3, 5, 13, 89', () => {
    [2, 3, 5, 13, 89].forEach(n => Assert.deepEqual(Submission.isPrime(n), true));
  });

  it('debería retornar false para ', () => {
    [4, 10, 99, 411].forEach(n => Assert.deepEqual(Submission.isPrime(n), false));
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});
",
          },
        },
        "title": "getPrimes()",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio por procedimientos",
    "type": "practice",
  },
  "08-oop": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe frameborder=\\"0\\" src=\\"//fast.wistia.net/embed/iframe/8id6wdxrdn?videoFoam=true\\" allowtransparency=\\"true\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" width=\\"100%\\" height=\\"100%\\"></iframe></div></p>
<p>La <strong>Programaci&#xF3;n Orientada a Objetos</strong> (<em>Object Oriented Programming</em> - OOP)
representa un cambio de paradigma bastante grande con respecto al paradigma por
procedimientos que acabamos de ver. Cuando programamos por procedimientos nos
concentramos en funciones, que representan acciones, y as&#xED; nuestra sem&#xE1;ntica
est&#xE1; orientada a acciones antes que a estructuras de datos.</p>
<p>En la programaci&#xF3;n orientada a objetos le damos la vuelta a la tortilla, y en
vez de pensar en acciones nos enfocamos en definir los &quot;tipos&quot; de datos primero,
y despu&#xE9;s decidimos que interacciones van a tener. En OOP dise&#xF1;amos objetos, que
van a tener una data (un estado) y una serie de operaciones que pueden realizar.</p>
<p>A la hora de construir aplicaciones nos vemos obligados a pensar en c&#xF3;mo
&quot;modelar&quot; o representar en c&#xF3;digo cosas del mundo real o conceptos &#xFA;tiles para
un ser humano (un usuario, un documento, ...) y la programaci&#xF3;n orientada a
objetos propone crear tipos de objetos para representar estas cosas.</p>
<p>Imaginemos que tenemos que escribir una aplicaci&#xF3;n de &quot;notas&quot; donde el usuario
puede crear diferentes tipos de &quot;notas&quot;, marcarlas como completadas, ... Si
vamos a seguir el estilo orientado a objetos, normalmente empezar&#xED;amos por
modelar el &quot;tipo de objeto&quot; que con el que vamos a representar una &quot;nota&quot;.
Podr&#xED;amos empezar con algo as&#xED;:</p>
<pre><code class=\\"language-js\\">function Note(text) {
  this.text = text || &apos;&apos;;
  this.createdAt = new Date();
  this.completed = false;
}</code></pre>
<p>Hemos declarado una funci&#xF3;n (<code>Note</code>) que hace uso de una <em>pseudo variable</em>
llamada <code>this</code>. La presencia de <code>this</code>, junto con la convenci&#xF3;n de usar la
primera letra en may&#xFA;scula, nos indican que esta funci&#xF3;n est&#xE1; escrita
para ser invocada con el <em>keyword</em> <code>new</code>. Este tipo de funci&#xF3;n es lo que
conocemos como un <em>constructor</em>. Los constructores son funciones cuyo prop&#xF3;sito
es crear un objeto, inicializarlo y ofrecernos una manera de especificar el
prototipo que tendr&#xE1;n los objetos creados con este constructor. Dicho de otra
manera, menos correcta pero m&#xE1;s com&#xFA;n, los constructores son lo m&#xE1;s parecido a
clases en JavaScript (por lo menos hasta ES6).</p>
<p>JavaScript es un lenguaje din&#xE1;micamente tipado (<em>dynamically typed</em>), pero a
diferencia de la mayor&#xED;a de lenguajes de su generaci&#xF3;n, usa herencia prototipal
en vez de clases, lo cual suele confundir a muchos programadores con experiencia
en otros lenguajes orientados a objetos.</p>
<p>Cuando invocamos un constructor precedido de <code>new</code>, la pseudo-variable <code>this</code> es
una referencia al nuevo objeto creado al invocar el constructor. Creemos un
objeto para ver que significa todo esto:</p>
<pre><code class=\\"language-js\\">const note = new Note(&apos;comprar arroz&apos;);
console.log(note);</code></pre>
<p>En la consola deber&#xED;as de ver algo as&#xED;:</p>
<pre><code class=\\"language-text\\">Note {
  text: &apos;comprar arroz&apos;,
  createdAt: 2017-06-14T22:39:51.987Z,
  completed: false }</code></pre>
<p>Podemos ver que <code>note</code> es un objeto con tres propiedades (<code>text</code>, <code>createdAt</code> y
<code>completed</code>). Estas tres propiedades est&#xE1;n declaradas directamente sobre la
instancia.</p>
<p>Cuando usamos constructores, es importante acordarnos de usar <code>new</code> a la hora de
invocarlos, si no, el constructor retornar&#xE1; <code>undefined</code>.</p>
<pre><code class=\\"language-js\\">const note = Note(&apos;comprar arroz&apos;);
console.log(note); // undefined</code></pre>
<p>Hemos dicho que una de las caracter&#xED;sticas fundamentales de OOP es que empezamos
por definir los tipos de datos (ya sea con clases, constructores, prototipos,
...), lo cual nos permite inspeccionar los objetos creados para saber si son
una instacia de un constructor (con el operador <code>instanceof</code>) o comprobar si un
objeto est&#xE1; en la cadena de prototipos de otro objeto
(<code>Object.prototype.isPrototypeOf</code>).</p>
<pre><code class=\\"language-js\\">console.log(note instanceof Note); // true
console.log(Note.prototype.isPrototypeOf(note)); // true</code></pre>
<p>Ahora que ya hemos definido un constructor que inicializa una serie de
propiedades, podemos usar el prototipo del constructor (<code>Note.prototype</code>) para
a&#xF1;adir funcionalidad. Todo lo que le a&#xF1;adamos a <code>Note.prototype</code> ser&#xE1; parte del
prototipo de los objetos creados por <code>new Note()</code>. A&#xF1;adamos un m&#xE9;todo al
prototipo de <code>Note</code>:</p>
<pre><code class=\\"language-js\\">Note.prototype.toString = function () {
  let str = &apos;[&apos; + (this.completed ? &apos;X&apos; : &apos; &apos;) + &apos;]&apos;;
  str += &apos; | &apos; + this.createdAt.toDateString();
  str += &apos; | &apos; + this.text;
  return str;
};</code></pre>
<p>Hemos a&#xF1;adido el m&#xE9;todo <code>Note.prototype.toString</code>, que simplemente retorna una
representaci&#xF3;n de nuestro objeto como string. Ahora todos los objetos que
creemos con <code>new Note()</code> deber&#xED;an de &quot;heredar&quot; un m&#xE9;todo <code>toString</code>. Si hacemos
<code>console.log(note)</code> veremos las tres propiedades que seteamos en el constructor,
pero qu&#xE9; pas&#xF3; con el m&#xE9;todo <code>toString</code> que le hab&#xED;amos  a&#xF1;adimo al prototipo de
<code>Note</code>?</p>
<p>Inspeccionemos un poco...</p>
<pre><code class=\\"language-js\\">console.log(note.prototype); // undefined
console.log(note.__proto__); // Note { toString: [Function] }
console.log(note.toString); // [Function]</code></pre>
<p>El objeto <code>note</code> s&#xED; tiene el m&#xE9;todo <code>toString</code>, pero no directamente sobre la
instancia, si no que est&#xE1; en su prototipo. Cuando tratamos de acceder a una
propiedad que no existe en un objeto, JavaScript va a buscar a ver si hay una
propiedad con ese nombre en el prototipo del objeto, si la encuentra usar&#xE1; esa,
si no buscar&#xE1; en el prototipo del prototipo, y as&#xED; ir&#xE1; recorriendo lo que
conocemos como la cadena de prototipos (prototype chain).</p>
<p>En la programaci&#xF3;n orientada a objetos el principal mecanismo de reuso de c&#xF3;digo
es la &quot;herencia&quot;, donde un objeto &quot;hereda&quot; una serie de propiedades y m&#xE9;todos
de otro objeto o clase (en herencia prototipal heredamos directamente de un
objeto en vez de una clase).</p>
<p>En la pr&#xF3;xima unidad de este curso exploraremos los detalles de c&#xF3;mo implementar
jerarqu&#xED;as de herencia usando prototipos. Por el momento nos quedamos con estos
conceptos.</p>
<p>Ahora que hemos visto qu&#xE9; es la programaci&#xF3;n orientada a objetos en el contexto
de JavaScript, concluyamos con una lista de caracter&#xED;sticas que definen a OOP de
forma m&#xE1;s general, por el propio Alan Kay, creador del t&#xE9;rmino OOP y Smalltalk:</p>
<blockquote>
<p>Traducido al espa&#xF1;ol:</p>
<ul>
<li>Todo es un objeto</li>
<li>Los objetos se comunican enviando y recibiendo mensajes (en t&#xE9;rminos de objetos)</li>
<li>Los objetos deben tener su propia memoria (en t&#xE9;rminos de objetos)</li>
<li>Todo objeto es una instancia de una clase (que debe ser un objeto)</li>
<li>La clase tiene el comportamiento compartido para las instancias (como objetos
en un programa)</li>
<li>Para evaluar un programa, se pasa el control al primer objeto y el resto se
trata como su mensaje.</li>
</ul>
<p>Original en ingl&#xE9;s:</p>
<ul>
<li>Everything Is An Object</li>
<li>Objects communicate by sending and receiving messages (in terms of objects).</li>
<li>Objects have their own memory (in terms of objects).</li>
<li>Every object is an instance of a class (which must be an object).</li>
<li>The class holds the shared behavior for its instances (in the form of objects
in a program list)</li>
<li>To eval a program list, control is passed to the first object and the
remainder is treated as its message.</li>
</ul>
<p>Fuente <a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></p>
</blockquote>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors</a>,
Faraz Kelhini, CSS Tricks, Sep 24 2015</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Object-oriented_programming\\" target=\\"_blank\\">Object-oriented programming</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">MDN - instanceof</a></li>
</ul>
",
    "duration": 15,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/8id6wdxrdn?wvideo=8id6wdxrdn",
        "id": "8id6wdxrdn",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "OOP",
    "type": "read",
  },
  "09-oop-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-notes": Object {
        "body": "<p>En la programaci&#xF3;n orientada a objetos (OOP), nos concentramos en describir
objetos, que tienen una data (un estado) y una serie de operaciones que pueden
realizar.</p>
<p>Imaginemos que estamos construyendo una aplicaci&#xF3;n de &quot;notas&quot;, donde el usuario
puede a&#xF1;adir notas con un texto. Antes de empezar a implementar tratamos de
imaginarnos los objetos que participan de este proceso. Lo primero que se nos
viene a la mente es que vamos a necesitar objetos de tipo &quot;nota&quot;.</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El boilerplate contiene dos constructores (<code>Note</code> y <code>Notes</code>). El primero
(<code>Note</code>) ya est&#xE1; implemetado. Ahora nos piden implementar los m&#xE9;todos
<code>Notes.prototype.add</code> y <code>Notes.prototype.toString</code>.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<p>Una vez implementado el ejercicio, alguien que importe tu m&#xF3;dulo deber&#xED;a de
poder hacer lo siguiente:</p>
<pre><code class=\\"language-js\\">const note1 = new Note(&apos;hola&apos;);
const note2 = new Note(&apos;mundo&apos;);
const notes = new Notes();

notes.add(note1);
notes.add(note2);

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

note1.completed = true;

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li><code>Notes.prototype.add</code> debe botar error (throw) si el argumento (<code>note</code>) no es
una instancia de <code>Note</code>.</li>
<li><code>Notes.prototype.add</code> debe a&#xF1;adir nuevas notas al principio de <code>this.data</code>, no
al final.</li>
<li>La implementaci&#xF3;n de <code>Notes.prototype.toString</code> debe iterar sobre las notas e
invocar <code>toString</code> en cada nota y as&#xED; ir concatenando el resultado. El string
que retornes debe contener una l&#xED;nea para cada nota (ver ejemplo).</li>
<li>El m&#xE9;todo <code>Notes.prototype.toString</code> debe listar las notas ordenadas por fecha
de creaci&#xF3;n descendente, la &#xFA;ltima a&#xF1;adida debe aparecer primero.</li>
<li>No olvides exportar los constructores <code>Note</code> y <code>Notes</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">Operators: instanceof - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\\" target=\\"_blank\\">Array#unshift - MDN</a></li>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors - CSS Tricks</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

// Convierte note en un string con este formato:
// [X] | Mon Jun 12 2017 | mundo
Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  //...
};

Notes.prototype.toString = function () {
  //...
};
",
          },
          "c29sdXRpb24=": Object {
            "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  if (!(note instanceof Note)) {
    throw new Error('Wrong type!');
  }

  this.data.unshift(note);
};

Notes.prototype.toString = function () {
  let str = '';
  for (let i = 0; i < this.data.length; i++) {
    if (i > 0) {
      str += '\\\\n';
    }
    str += this.data[i].toString();
  }
  return str;
};


exports.Note = Note;
exports.Notes = Notes;
",
          },
          "dGVzdA==": Object {
            "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const Note = Submission.Note;
const Notes = Submission.Notes;


describe('Note', () => {

  it('debería exportar función \`Note\`', () => {
    Assert.equal(typeof Note, 'function');
  });

  it('debería crear un nuevo objeto cuando invocamos new Note()', () => {
    const note = new Note('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
  });

  it('debería retornar undefined cuando invocamos Note() sin \\"new\\"', () => {
    Assert.equal(Note('renovar dni'), undefined);
  });

});


describe('Note#toString', () => {

  it('debería convertir objeto a string', () => {
    const note = new Note('foo');
    const date = (new Date()).toDateString();
    Assert.equal(note.toString(), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(note.toString(), '[X] | ' + date + ' | foo');
  });

});


describe('Notes (oop)', () => {

  it('debería exportar función \`Notes\`', () => {
    Assert.equal(typeof Notes, 'function');
  });

});


describe('Notes#add', () => {

  it('debería botar error cuando argumento no es instancia de Note', () => {
    [
      undefined, null, true, false, 0, 1, 3.14, '', 'foo', [], [1, 2], {},
      {foo: 'bar'}, new Date(), function () {}
    ].forEach((val) => {

      const notes = new Notes();
      Assert.throws(_ => notes.add(val), Error);
    });
  });


  it('debería permitir añadir instancias de Note', () => {
    const notes = new Notes();
    Assert.doesNotThrow(_ => notes.add(new Note('one')));
  });

});


describe('Notes#toString', () => {

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = new Notes();
    Assert.equal(notes.toString(), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = new Notes();
    const note1 = new Note('one');
    const date = (new Date()).toDateString();

    notes.add(note1);
    notes.add(new Note('two'));

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    note1.completed = true;

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
          },
        },
        "title": "Notes (OOP)",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio OOP",
    "type": "practice",
  },
  "10-fp": Object {
    "body": "<p>Finalmente llegamos al paradigma funcional (<em>Functional Programming</em>), y digo
finalmente porque es probable que sientas curiosidad por conocer un poco m&#xE1;s
sobre este paradigma tan incomprendido, pero tan de moda en el mundo de
JavaScript.</p>
<p>A diferencia del paradigma procedural y el orientado a objetos, la programaci&#xF3;n
funcional pertenece a la rama de los paradigmas <em>declarativos</em>. Esto quiere
decir que el &quot;estilo&quot; en el que programamos va a estar mucho m&#xE1;s enfocado en qu&#xE9;
queremos hacer y no tanto en los detalles de c&#xF3;mo la computadora lo ejecuta.</p>
<p>Cuando hablamos del estilo imperativo dijimos que nos enfoc&#xE1;bamos en asignar
valores a variables, mutar esas variables, e iterar usando bucles. La
programaci&#xF3;n funcional se caracteriza por exactamente lo opuesto. <strong>En FP el
principal mecanismo de c&#xF3;mputo es la aplicaci&#xF3;n de argumentos a funciones</strong>.
Como consecuencia, evitamos la asignaci&#xF3;n de varialbles, mutaci&#xF3;n, delegamos el
control de flujo, ... De hecho, podemos resumir los principios de la
programaci&#xF3;n funcional en los siguientes:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composici&#xF3;n</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no &quot;mutar&quot; valores asignados)</li>
<li><strong>Evitar el &quot;estado&quot; compartido</strong> (no usar referencias fuera del scope de la
funci&#xF3;n)</li>
<li>Uso de <strong>recursi&#xF3;n</strong> como alternativa a la iteraci&#xF3;n.</li>
</ul>
<p>Veamos estos conceptos en acci&#xF3;n:</p>
<pre><code class=\\"language-js\\">// pasando una funci&#xF3;n an&#xF3;nima como un argumento
setTimeout(function () {
  //...
}, 100);


// recibiendo una funci&#xF3;n como un argumento
function map(arr, fn) {
  const results = [];
  for (let i = 0; i &lt; arr.length; i++) {
    results.push(fn(arr[i]));
  }
  return results;
}

// Ahora reemplazando iteraci&#xF3;n con recursividad
function recursiveMap(arr, fn) {
  if (!arr.length) {
    return [];
  }
  return [fn(arr[0])].concat(recursiveMap(arr.slice(1), fn));
}</code></pre>
<p>La &#xFA;ltima funci&#xF3;n (<code>recursiveMap</code>) es un buen ejemplo de FP porque muestra como
podemos recibir una funci&#xF3;n como argumento, reemplzar iteraci&#xF3;n por recursi&#xF3;n,
evitar asignaci&#xF3;n y mutaci&#xF3;n. Adem&#xE1;s no accede a ninguna referencia fuera de su
scope (s&#xF3;lo usa variables locales) y no tiene ning&#xFA;n efecto secundario: se
limita a producir un valor de retorno a partir de su input (argumentos) sin
afectar nada fuera de su <em>scope</em>.</p>
<p>Para comparar con el ejemplo que hicimos de OOP, ahora vamos a crear una funci&#xF3;n
que cree objetos, algo parecido a un constructor, pero muy distinto a la vez.
Los constructores son un tipo de funci&#xF3;n especial que se invoca con <code>new</code>, usa
<code>this</code> internamente y define un prototipo. La funci&#xF3;n que vamos a implementar
ahora se va a limitar a crear un objeto y retornarlo, nada de <code>new</code>, <code>this</code> o
<code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = function (name) {
  return {
    name: name,
    active: false
  };
};</code></pre>
<p>ES2015 introduce &quot;arrow functions&quot; (funciones flecha), que es una implementaci&#xF3;n
de funciones muy parecida al keyword <code>function</code>, pero que no implica <code>new</code>,
<code>this</code> ni <code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = (name) =&gt; {
  return {
    name: name,
    active: false
  };
};</code></pre>
<hr>
<p>PRO TIP:</p>
<p>Con un poquito m&#xE1;s de az&#xFA;car sint&#xE1;ctica cortes&#xED;a de ES2015:</p>
<pre><code class=\\"language-js\\">const createRobot = name =&gt; ({
  name,
  active: false
});</code></pre>
<p>Cuando el cuerpo de la funci&#xF3;n es s&#xF3;lo una expresi&#xF3;n (un objeto literal en
nuestro caso), las &quot;arrow functions&quot; nos permiten hacer <em>retorno impl&#xED;cito</em>, lo
que significa que podemos obviar los <code>{}</code> que determinan el &quot;bloque&quot; de la
funci&#xF3;n y el keyword <code>return</code>. El resultado de evaluar la expresi&#xF3;n ser&#xE1; el
valor de retorno. En este ejemplo hemos envuelto la expresi&#xF3;n (el objeto
literal) en par&#xE9;ntesis <code>()</code> para evitar que los <code>{}</code> se confundan con el cuerpo
de la funci&#xF3;n. En este caso los curly braces son parte del objeto!</p>
<hr>
<p>En FP, en vez de pensar en &quot;tipos&quot;, normalmente nos centramos en
transformaciones. Es decir, una funci&#xF3;n recibe un input (argumentos) y de alguna
forma los &quot;transforma&quot; en otra cosa. Por ejemplo, en la funci&#xF3;n anterior,
podemos decir que la funci&#xF3;n <code>createRobot</code> transforma un <code>string</code> (su input) en
un objeto (su valor de retorno). De esta forma cada funci&#xF3;n est&#xE1; completamente
aislada del mundo exterior y se concentra en hacer s&#xF3;lo una cosa.</p>
<p>Un buen ejemplo para visualzar el concepto de transformaci&#xF3;n es el m&#xE9;todo
<code>Array#map</code> en JavaScript (muy parecido al map que acabamos de implementar).
<code>Array.prototype.map</code> recibe un argumento, una funci&#xF3;n que ser&#xE1; invocada para
cada elemento del array, y retorna un nuevo arreglo con los resultados de cada
invocaci&#xF3;n a la funci&#xF3;n que recibe <code>Array#map</code> como argumento.</p>
<pre><code class=\\"language-js\\">const array = [&apos;1&apos;, &apos;02&apos;, &apos;33&apos;, &apos;3.14&apos;, &apos;028&apos;];

const double = num =&gt; num + num;

console.log(array.map(double));
// [ &apos;11&apos;, &apos;0202&apos;, &apos;3333&apos;, &apos;3.143.14&apos;, &apos;028028&apos; ]

console.log(array.map(parseFloat));
// [ 1, 2, 33, 3.14, 28 ]

console.log(array.map(parseFloat).map(double));
// [ 2, 4, 66, 6.28, 56 ]

const arrayToDouble = array =&gt; array.map(parseFloat).map(double);

console.log(arrayToDouble(array));
// [ 2, 4, 66, 6.28, 56 ]</code></pre>
<p>Como vemos en estos ejemplos, podemos encadenar invocaciones a <code>Array#map</code> para
ir &quot;transformando&quot; los elementos de un arreglo, ya que cada invocaci&#xF3;n retorna
un array.</p>
<h2 id=\\"qu&#xE9;-ventajas-ofrece\\">Qu&#xE9; ventajas ofrece?</h2>
<ul>
<li>C&#xF3;mo hemos visto en el ejemplo de arriba, el c&#xF3;digo funcional tiende a ser m&#xE1;s
conciso y expresivo.</li>
<li>M&#xE1;s predecible. M&#xE1;s adelante veremos que como resultado de los principios del
paradigma (uso de funciones puras, inmutabilidad, evitar estado compartido y
efectos secundarios, ...) nuestro c&#xF3;digo ser&#xE1; m&#xE1;s f&#xE1;cil de predecir, aislar y
probar.</li>
<li>Se presta a la paralelizaci&#xF3;n y la computaci&#xF3;n distribuida.</li>
<li>Se presta a la asincr&#xF3;nia.</li>
<li>JavaScript, como lenguaje, tiene una naturaleza m&#xE1;s funcional que imperativa.</li>
</ul>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\\" target=\\"_blank\\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,
Eric Elliott en Medium, Feb 20 2017</li>
<li><a href=\\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\\" target=\\"_blank\\">JavaScript and Functional Programming</a>,
Beth Allchurch, 29 of June, 2016</li>
<li><a href=\\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\\" target=\\"_blank\\">An introduction to functional programming</a>,
Mary Rose Cook</li>
<li><a href=\\"https://medium.com/laboratoria-how-to/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-1-e0b1d0b2142e\\" target=\\"_blank\\">Introducci&#xF3;n a programaci&#xF3;n funcional en JavaScript&#x200A;&#x2014;&#x200A;Parte 1</a>,
Lupo Montero en Medium, Feb 15 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">MDN - Arrow functions</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">MDN - Array.prototype.map</a></li>
</ul>
",
    "duration": 10,
    "format": "self-paced",
    "title": "FP",
    "type": "read",
  },
  "11-fp-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-notes": Object {
        "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa tres funciones con las siguientes &quot;firmas&quot;:</p>
<h3 id=\\"createnotetext\\"><code>createNote(text)</code></h3>
<p>Esta funci&#xF3;n debe crear un objeto literal con tres propiedades (ver retorno).</p>
<h4 id=\\"argumentos\\">Argumentos</h4>
<ul>
<li><code>text</code>: un string con el texto de la nota</li>
</ul>
<h4 id=\\"retorno\\">Retorno</h4>
<p>Un objeto con 3 propiedades:</p>
<ul>
<li><code>text</code>: el texto de la nota.</li>
<li><code>createdAt</code>: objeto tipo <code>Date</code> creado cuando se invoca <code>createNote</code>.</li>
<li><code>completed</code>: un booleano con valor <code>false</code> por defecto.</li>
</ul>
<h3 id=\\"createnotesarray\\"><code>createNotes(array)</code></h3>
<p>Crea un arreglo de objetos a partir de un arreglo de strings. Cada objeto en el
nuevo arreglo ser&#xE1; creado usando <code>createNote</code>.</p>
<h4 id=\\"argumentos-1\\">Argumentos</h4>
<ul>
<li><code>array</code>: Un array de strings con los textos de las notas.</li>
</ul>
<h4 id=\\"retorno-1\\">Retorno</h4>
<p>Un arreglo de objetos donde cada objeto tiene la estructura esperada de nota.</p>
<h3 id=\\"notestostringnotes\\"><code>notesToString(notes)</code></h3>
<p>Convierte un arreglo de notas (objetos con la estructura que hemos visto) en un
string. Para ello debe invocar <code>noteToString</code> para cada elemento en el array.</p>
<h4 id=\\"argumentos-2\\">Argumentos</h4>
<ul>
<li><code>notes</code>: Un arreglo de objetos (notas).</li>
</ul>
<h4 id=\\"retorno-2\\">Retorno</h4>
<p>Un string donde tenemos una l&#xED;nea por cada nota.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<pre><code class=\\"language-js\\">const notes = createNotes([&apos;hola&apos;, &apos;mundo&apos;]);

console.log(notes);

// [ { text: &apos;hola&apos;,
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false },
//  { text: &apos;mundo&apos;,
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false } ]

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

notes[0].completed = true;

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Tu m&#xF3;dulo debe exportar cuatro funciones: <code>createNote</code>, <code>noteToString</code>,
<code>createNotes</code> y <code>notesToString</code>.</li>
<li>Tus funciones deben de ser &quot;puras&quot; (no side effects).</li>
<li>Evita usar asignaci&#xF3;n dentro del cuerpo de las funciones.</li>
<li>Usa <code>Array#map</code> para implementar <code>createNotes</code> y <code>notesToString</code>.</li>
<li>Todas las funciones deben ser &quot;arrow functions&quot;</li>
</ul>
<h2 id=\\"bonus-points\\">Bonus points</h2>
<ul>
<li>Evita usar el &quot;keyword&quot; <code>return</code> cuando puedas usar retorno impl&#xED;cito.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">Arrow functions - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">Array#map - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\\" target=\\"_blank\\">Array#join - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\\" target=\\"_blank\\">Date - MDN</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "bm90ZXMuanM=": "const createNote = text => {}; // debes implementar esta función ;-)

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => {}; // debes implementar esta función ;-)

const notesToString = notes => {}; // debes implementar esta función ;-)
",
          },
          "c29sdXRpb24=": Object {
            "bm90ZXMuanM=": "const createNote = text => ({
  text,
  createdAt: new Date(),
  completed: false
});

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => array.map(createNote);

const notesToString = notes => notes.map(noteToString).join('\\\\n');

exports.createNote = createNote;
exports.noteToString = noteToString;
exports.createNotes = createNotes;
exports.notesToString = notesToString;
",
          },
          "dGVzdA==": Object {
            "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const { createNote, noteToString, createNotes, notesToString } = Submission;


describe('createNote()', () => {

  it('debería exportar función \`createNote\`', () => {
    Assert.equal(typeof createNote, 'function');
  });

  it('debería crear un objeto con los campos esperados', () => {
    const note = createNote('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
    Assert.equal(note.__proto__, Object.prototype);
  });

});

describe('noteToString()', () => {

  it('debería exportar función \`noteToString\`', () => {
    Assert.equal(typeof noteToString, 'function');
  });

  it('debería convertir objeto a string', () => {
    const note = createNote('foo');
    const date = (new Date()).toDateString();
    Assert.equal(noteToString(note), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(noteToString(note), '[X] | ' + date + ' | foo');
  });

});

describe('createNotes()', () => {

  it('debería exportar función \`createNotes\`', () => {
    Assert.equal(typeof createNotes, 'function');
  });

});

describe('notesToString()', () => {

  it('debería exportar función \`notesToString\`', () => {
    Assert.equal(typeof notesToString, 'function');
  });

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = createNotes([]);
    Assert.equal(notesToString(notes), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = createNotes(['one']);
    const date = (new Date()).toDateString();

    notes.unshift(createNote('two'));

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    notes[1].completed = true;

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
          },
        },
        "title": "Notes (FP)",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio FP",
    "type": "practice",
  },
  "13-closing": Object {
    "body": "<h2 id=\\"resumen\\">Resumen</h2>
<p>Los <strong>Paradigmas de Programaci&#xF3;n</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en c&#xF3;mo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Algunos paradigmas son m&#xE1;s <strong>imperativos</strong> y otros m&#xE1;s <strong>declarativos</strong>. Por
ejemplo, la programaci&#xF3;n orientada a procedimientos, o la programaci&#xF3;n orientada
objetos, van a tener un caracter imperativo, mientras que la programaci&#xF3;n
funcional tiene un caracter mucho m&#xE1;s declarativo.</p>
<p>La <strong>programaci&#xF3;n por procedimientos</strong> (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Cuando programamos orientados a procedimientos nos
concentramos en agrupar c&#xF3;digo en procedimientos o funciones.</p>
<p>En la <strong>programaci&#xF3;n orientada a objetos</strong> , vez de pensar en acciones nos
enfocamos en definir los &quot;tipos&quot; de datos primero, y despu&#xE9;s decidimos que
interacciones van a tener. En OOP dise&#xF1;amos objetos, que van a tener una data
(un estado) y una serie de operaciones que pueden realizar.</p>
<p>En la <strong>programaci&#xF3;n orientada a objetos</strong> el principal mecanismo de reuso de
c&#xF3;digo es la <strong>herencia</strong>, donde un objeto &quot;hereda&quot; una serie de propiedades y
m&#xE9;todos de otro objeto o clase (en <em>herencia prototipal</em> heredamos directamente
de un objeto en vez de una clase).</p>
<p>La <strong>programaci&#xF3;n funcional</strong> pertenece a la rama de los paradigmas
<em>declarativos</em>. Esto quiere decir que el &quot;estilo&quot; en el que programamos va a
estar mucho m&#xE1;s enfocado en <em>qu&#xE9; queremos hacer</em> y no tanto en los detalles de
<em>c&#xF3;mo la computadora lo ejecuta</em>.</p>
<p>En FP el principal mecanismo de c&#xF3;mputo es la aplicaci&#xF3;n de argumentos a
funciones. Como consecuencia, evitamos la asignaci&#xF3;n de varialbles, mutaci&#xF3;n y
delegamos el control de flujo.</p>
<p>Principios de la programaci&#xF3;n funcional:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composici&#xF3;n</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no &quot;mutar&quot; valores asignados)</li>
<li><strong>Evitar el &quot;estado&quot; compartido</strong> (no usar referencias fuera del scope de la
funci&#xF3;n)</li>
<li>Uso de <strong>recursi&#xF3;n</strong> como alternativa a la iteraci&#xF3;n.</li>
</ul>
<h2 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h2>
<ul>
<li>Qu&#xE9; son los <strong>paradigmas de programaci&#xF3;n</strong>?</li>
<li>Qu&#xE9; es el estilo <strong>imperativo</strong></li>
<li>Qu&#xE9; es el estilo <strong>declarativo</strong></li>
<li>Qu&#xE9; paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n por procedimientos</strong>?</li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n orientada a objetos</strong>?</li>
<li>Qu&#xE9; es la <strong>programaci&#xF3;n funcional</strong>?</li>
<li>C&#xF3;mo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>C&#xF3;mo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>C&#xF3;mo programar en los diferentes estilos</li>
</ul>
",
    "duration": 5,
    "format": "self-paced",
    "title": "Cierre",
    "type": "read",
  },
}
`;
